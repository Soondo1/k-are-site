"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gray-matter";
exports.ids = ["vendor-chunks/gray-matter"];
exports.modules = {

/***/ "(rsc)/./node_modules/gray-matter/index.js":
/*!*******************************************!*\
  !*** ./node_modules/gray-matter/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar extend = __webpack_require__(/*! extend-shallow */ \"(rsc)/./node_modules/extend-shallow/index.js\");\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \"(rsc)/./node_modules/gray-matter/lib/parsers.js\");\n\n/**\n * Expose `matter()`\n */\n\nmodule.exports = matter;\n\n/**\n * Parses a `string` of front-matter with the given `options`,\n * and returns an object.\n *\n * ```js\n * matter('---\\ntitle: foo\\n---\\nbar');\n * //=> {data: {title: 'foo'}, content: 'bar', orig: '---\\ntitle: foo\\n---\\nbar'}\n * ```\n *\n * @param {String} `string` The string to parse.\n * @param {Object} `options`\n *   @option {Array} [options] `delims` Custom delimiters formatted as an array. The default is `['---', '---']`.\n *   @option {Function} [options] `parser` Parser function to use. [js-yaml] is the default.\n * @return {Object} Valid JSON\n * @api public\n */\n\nfunction matter(str, options) {\n  if (typeof str !== 'string') {\n    throw new Error('gray-matter expects a string');\n  }\n\n  // default results to build up\n  var res = {orig: str, data: {}, content: str};\n  if (str === '') {\n    return res;\n  }\n\n  // delimiters\n  var delims = arrayify((options && options.delims) || '---');\n  var a = delims[0];\n\n  // strip byte order marks\n  str = stripBom(str);\n\n  // if the first delim isn't the first thing, return\n  if (!isFirst(str, a)) {\n    return res;\n  }\n\n  var b = '\\n' + (delims[1] || delims[0]);\n  var alen = a.length;\n\n  // if the next character after the first delim\n  // is a character in the first delim, then just\n  // return the default object. it's either a bad\n  // delim or not a delimiter at all.\n  if (a.indexOf(str.charAt(alen + 1)) !== -1) {\n    return res;\n  }\n\n  var len = str.length;\n\n  // find the index of the next delimiter before\n  // going any further. If not found, return.\n  var end = str.indexOf(b, alen + 1);\n  if (end === -1) {\n    end = len;\n  }\n\n  // detect a language, if defined\n  var lang = str.slice(alen, str.indexOf('\\n'));\n  // measure the lang before trimming whitespace\n  var start = alen + lang.length;\n\n  var opts = options || {};\n  opts.lang = opts.lang || 'yaml';\n  lang = (lang && lang.trim()) || opts.lang;\n\n  // get the front matter (data) string\n  var data = str.slice(start, end).trim();\n  if (data) {\n    // if data exists, see if we have a matching parser\n    var fn = opts.parser || parsers[lang];\n    if (typeof fn === 'function') {\n      // run the parser on the data string\n      res.data = fn(data, opts);\n    } else {\n      throw new Error('gray-matter cannot find a parser for: ' + str);\n    }\n  }\n\n  // grab the content from the string, stripping\n  // an optional new line after the second delim\n  var con = str.substr(end + b.length);\n  if (con.charAt(0) === '\\n') {\n    con = con.substr(1);\n  } else if (con.charAt(0) === '\\r' && con.charAt(1) === '\\n') {\n    con = con.substr(2);\n  }\n\n  res.content = con;\n  return res;\n}\n\n/**\n * Expose `parsers`\n *\n * @type {Object}\n */\n\nmatter.parsers = parsers;\n\n/**\n * Requires cache\n */\n\nvar YAML = matter.parsers.requires.yaml || (matter.parsers.requires.yaml = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/index.js\"));\n\n/**\n * Read a file and parse front matter. Returns the same object\n * as `matter()`.\n *\n * ```js\n * matter.read('home.md');\n * ```\n *\n * @param {String} `fp` file path of the file to read.\n * @param {Object} `options` Options to pass to gray-matter.\n * @return {Object}\n * @api public\n */\n\nmatter.read = function(fp, options) {\n  var str = fs.readFileSync(fp, 'utf8');\n  var obj = matter(str, options);\n  return extend(obj, {\n    path: fp\n  });\n};\n\n/**\n * Stringify an object to front-matter-formatted YAML, and\n * concatenate it to the given string.\n *\n * ```js\n * matter.stringify('foo bar baz', {title: 'Home'});\n * ```\n * Results in:\n *\n * ```yaml\n * ---\n * title: Home\n * ---\n * foo bar baz\n * ```\n *\n * @param {String} `str` The content string to append to stringified front-matter.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` Options to pass to js-yaml\n * @return {String}\n * @api public\n */\n\nmatter.stringify = function(str, data, options) {\n  var delims = arrayify(options && options.delims || '---');\n  var res = '';\n  res += delims[0] + '\\n';\n  res += YAML.safeDump(data, options);\n  res += (delims[1] || delims[0]) + '\\n';\n  res += str + '\\n';\n  return res;\n};\n\n/**\n * Return true if the given `string` has front matter.\n *\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n */\n\nmatter.test = function(str, options) {\n  var delims = arrayify(options && options.delims || '---');\n  return isFirst(str, delims[0]);\n};\n\n/**\n * Return true if the given `ch` the first\n * thing in the string.\n */\n\nfunction isFirst(str, ch) {\n  return str.substr(0, ch.length) === ch;\n}\n\n/**\n * Utility to strip byte order marks\n */\n\nfunction stripBom(str) {\n  return str.charAt(0) === '\\uFEFF' ? str.slice(1) : str;\n}\n\n/**\n * Typecast `val` to an array.\n */\n\nfunction arrayify(val) {\n  return !Array.isArray(val) ? [val] : val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3JheS1tYXR0ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsYUFBYSxtQkFBTyxDQUFDLG9FQUFnQjtBQUNyQyxjQUFjLG1CQUFPLENBQUMsc0VBQWU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU8sYUFBYTtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixjQUFjLE9BQU87QUFDckIsY0FBYyxVQUFVO0FBQ3hCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkVBQTJFLG1CQUFPLENBQUMsc0RBQVM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYXJlLy4vbm9kZV9tb2R1bGVzL2dyYXktbWF0dGVyL2luZGV4LmpzPzVjNjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYG1hdHRlcigpYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0dGVyO1xuXG4vKipcbiAqIFBhcnNlcyBhIGBzdHJpbmdgIG9mIGZyb250LW1hdHRlciB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AsXG4gKiBhbmQgcmV0dXJucyBhbiBvYmplY3QuXG4gKlxuICogYGBganNcbiAqIG1hdHRlcignLS0tXFxudGl0bGU6IGZvb1xcbi0tLVxcbmJhcicpO1xuICogLy89PiB7ZGF0YToge3RpdGxlOiAnZm9vJ30sIGNvbnRlbnQ6ICdiYXInLCBvcmlnOiAnLS0tXFxudGl0bGU6IGZvb1xcbi0tLVxcbmJhcid9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqICAgQG9wdGlvbiB7QXJyYXl9IFtvcHRpb25zXSBgZGVsaW1zYCBDdXN0b20gZGVsaW1pdGVycyBmb3JtYXR0ZWQgYXMgYW4gYXJyYXkuIFRoZSBkZWZhdWx0IGlzIGBbJy0tLScsICctLS0nXWAuXG4gKiAgIEBvcHRpb24ge0Z1bmN0aW9ufSBbb3B0aW9uc10gYHBhcnNlcmAgUGFyc2VyIGZ1bmN0aW9uIHRvIHVzZS4gW2pzLXlhbWxdIGlzIHRoZSBkZWZhdWx0LlxuICogQHJldHVybiB7T2JqZWN0fSBWYWxpZCBKU09OXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdHRlcihzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmF5LW1hdHRlciBleHBlY3RzIGEgc3RyaW5nJyk7XG4gIH1cblxuICAvLyBkZWZhdWx0IHJlc3VsdHMgdG8gYnVpbGQgdXBcbiAgdmFyIHJlcyA9IHtvcmlnOiBzdHIsIGRhdGE6IHt9LCBjb250ZW50OiBzdHJ9O1xuICBpZiAoc3RyID09PSAnJykge1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBkZWxpbWl0ZXJzXG4gIHZhciBkZWxpbXMgPSBhcnJheWlmeSgob3B0aW9ucyAmJiBvcHRpb25zLmRlbGltcykgfHwgJy0tLScpO1xuICB2YXIgYSA9IGRlbGltc1swXTtcblxuICAvLyBzdHJpcCBieXRlIG9yZGVyIG1hcmtzXG4gIHN0ciA9IHN0cmlwQm9tKHN0cik7XG5cbiAgLy8gaWYgdGhlIGZpcnN0IGRlbGltIGlzbid0IHRoZSBmaXJzdCB0aGluZywgcmV0dXJuXG4gIGlmICghaXNGaXJzdChzdHIsIGEpKSB7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBiID0gJ1xcbicgKyAoZGVsaW1zWzFdIHx8IGRlbGltc1swXSk7XG4gIHZhciBhbGVuID0gYS5sZW5ndGg7XG5cbiAgLy8gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGFmdGVyIHRoZSBmaXJzdCBkZWxpbVxuICAvLyBpcyBhIGNoYXJhY3RlciBpbiB0aGUgZmlyc3QgZGVsaW0sIHRoZW4ganVzdFxuICAvLyByZXR1cm4gdGhlIGRlZmF1bHQgb2JqZWN0LiBpdCdzIGVpdGhlciBhIGJhZFxuICAvLyBkZWxpbSBvciBub3QgYSBkZWxpbWl0ZXIgYXQgYWxsLlxuICBpZiAoYS5pbmRleE9mKHN0ci5jaGFyQXQoYWxlbiArIDEpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIG5leHQgZGVsaW1pdGVyIGJlZm9yZVxuICAvLyBnb2luZyBhbnkgZnVydGhlci4gSWYgbm90IGZvdW5kLCByZXR1cm4uXG4gIHZhciBlbmQgPSBzdHIuaW5kZXhPZihiLCBhbGVuICsgMSk7XG4gIGlmIChlbmQgPT09IC0xKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgLy8gZGV0ZWN0IGEgbGFuZ3VhZ2UsIGlmIGRlZmluZWRcbiAgdmFyIGxhbmcgPSBzdHIuc2xpY2UoYWxlbiwgc3RyLmluZGV4T2YoJ1xcbicpKTtcbiAgLy8gbWVhc3VyZSB0aGUgbGFuZyBiZWZvcmUgdHJpbW1pbmcgd2hpdGVzcGFjZVxuICB2YXIgc3RhcnQgPSBhbGVuICsgbGFuZy5sZW5ndGg7XG5cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRzLmxhbmcgPSBvcHRzLmxhbmcgfHwgJ3lhbWwnO1xuICBsYW5nID0gKGxhbmcgJiYgbGFuZy50cmltKCkpIHx8IG9wdHMubGFuZztcblxuICAvLyBnZXQgdGhlIGZyb250IG1hdHRlciAoZGF0YSkgc3RyaW5nXG4gIHZhciBkYXRhID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQpLnRyaW0oKTtcbiAgaWYgKGRhdGEpIHtcbiAgICAvLyBpZiBkYXRhIGV4aXN0cywgc2VlIGlmIHdlIGhhdmUgYSBtYXRjaGluZyBwYXJzZXJcbiAgICB2YXIgZm4gPSBvcHRzLnBhcnNlciB8fCBwYXJzZXJzW2xhbmddO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHJ1biB0aGUgcGFyc2VyIG9uIHRoZSBkYXRhIHN0cmluZ1xuICAgICAgcmVzLmRhdGEgPSBmbihkYXRhLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmF5LW1hdHRlciBjYW5ub3QgZmluZCBhIHBhcnNlciBmb3I6ICcgKyBzdHIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdyYWIgdGhlIGNvbnRlbnQgZnJvbSB0aGUgc3RyaW5nLCBzdHJpcHBpbmdcbiAgLy8gYW4gb3B0aW9uYWwgbmV3IGxpbmUgYWZ0ZXIgdGhlIHNlY29uZCBkZWxpbVxuICB2YXIgY29uID0gc3RyLnN1YnN0cihlbmQgKyBiLmxlbmd0aCk7XG4gIGlmIChjb24uY2hhckF0KDApID09PSAnXFxuJykge1xuICAgIGNvbiA9IGNvbi5zdWJzdHIoMSk7XG4gIH0gZWxzZSBpZiAoY29uLmNoYXJBdCgwKSA9PT0gJ1xccicgJiYgY29uLmNoYXJBdCgxKSA9PT0gJ1xcbicpIHtcbiAgICBjb24gPSBjb24uc3Vic3RyKDIpO1xuICB9XG5cbiAgcmVzLmNvbnRlbnQgPSBjb247XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRXhwb3NlIGBwYXJzZXJzYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxubWF0dGVyLnBhcnNlcnMgPSBwYXJzZXJzO1xuXG4vKipcbiAqIFJlcXVpcmVzIGNhY2hlXG4gKi9cblxudmFyIFlBTUwgPSBtYXR0ZXIucGFyc2Vycy5yZXF1aXJlcy55YW1sIHx8IChtYXR0ZXIucGFyc2Vycy5yZXF1aXJlcy55YW1sID0gcmVxdWlyZSgnanMteWFtbCcpKTtcblxuLyoqXG4gKiBSZWFkIGEgZmlsZSBhbmQgcGFyc2UgZnJvbnQgbWF0dGVyLiBSZXR1cm5zIHRoZSBzYW1lIG9iamVjdFxuICogYXMgYG1hdHRlcigpYC5cbiAqXG4gKiBgYGBqc1xuICogbWF0dGVyLnJlYWQoJ2hvbWUubWQnKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnBgIGZpbGUgcGF0aCBvZiB0aGUgZmlsZSB0byByZWFkLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBPcHRpb25zIHRvIHBhc3MgdG8gZ3JheS1tYXR0ZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1hdHRlci5yZWFkID0gZnVuY3Rpb24oZnAsIG9wdGlvbnMpIHtcbiAgdmFyIHN0ciA9IGZzLnJlYWRGaWxlU3luYyhmcCwgJ3V0ZjgnKTtcbiAgdmFyIG9iaiA9IG1hdHRlcihzdHIsIG9wdGlvbnMpO1xuICByZXR1cm4gZXh0ZW5kKG9iaiwge1xuICAgIHBhdGg6IGZwXG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gb2JqZWN0IHRvIGZyb250LW1hdHRlci1mb3JtYXR0ZWQgWUFNTCwgYW5kXG4gKiBjb25jYXRlbmF0ZSBpdCB0byB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBtYXR0ZXIuc3RyaW5naWZ5KCdmb28gYmFyIGJheicsIHt0aXRsZTogJ0hvbWUnfSk7XG4gKiBgYGBcbiAqIFJlc3VsdHMgaW46XG4gKlxuICogYGBgeWFtbFxuICogLS0tXG4gKiB0aXRsZTogSG9tZVxuICogLS0tXG4gKiBmb28gYmFyIGJhelxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBjb250ZW50IHN0cmluZyB0byBhcHBlbmQgdG8gc3RyaW5naWZpZWQgZnJvbnQtbWF0dGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGBkYXRhYCBGcm9udCBtYXR0ZXIgdG8gc3RyaW5naWZ5LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBPcHRpb25zIHRvIHBhc3MgdG8ganMteWFtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tYXR0ZXIuc3RyaW5naWZ5ID0gZnVuY3Rpb24oc3RyLCBkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBkZWxpbXMgPSBhcnJheWlmeShvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1zIHx8ICctLS0nKTtcbiAgdmFyIHJlcyA9ICcnO1xuICByZXMgKz0gZGVsaW1zWzBdICsgJ1xcbic7XG4gIHJlcyArPSBZQU1MLnNhZmVEdW1wKGRhdGEsIG9wdGlvbnMpO1xuICByZXMgKz0gKGRlbGltc1sxXSB8fCBkZWxpbXNbMF0pICsgJ1xcbic7XG4gIHJlcyArPSBzdHIgKyAnXFxuJztcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGhhcyBmcm9udCBtYXR0ZXIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyaW5nYFxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgZnJvbnQgbWF0dGVyIGV4aXN0cy5cbiAqL1xuXG5tYXR0ZXIudGVzdCA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICB2YXIgZGVsaW1zID0gYXJyYXlpZnkob3B0aW9ucyAmJiBvcHRpb25zLmRlbGltcyB8fCAnLS0tJyk7XG4gIHJldHVybiBpc0ZpcnN0KHN0ciwgZGVsaW1zWzBdKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGBjaGAgdGhlIGZpcnN0XG4gKiB0aGluZyBpbiB0aGUgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIGlzRmlyc3Qoc3RyLCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBjaC5sZW5ndGgpID09PSBjaDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIHN0cmlwIGJ5dGUgb3JkZXIgbWFya3NcbiAqL1xuXG5mdW5jdGlvbiBzdHJpcEJvbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgPT09ICdcXHVGRUZGJyA/IHN0ci5zbGljZSgxKSA6IHN0cjtcbn1cblxuLyoqXG4gKiBUeXBlY2FzdCBgdmFsYCB0byBhbiBhcnJheS5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbCkgPyBbdmFsXSA6IHZhbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gray-matter/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gray-matter/lib/parsers.js":
/*!*************************************************!*\
  !*** ./node_modules/gray-matter/lib/parsers.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * gray-matter <https://github.com/jonschlinkert/gray-matter.git>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * Module dependencies\n */\n\nvar extend = __webpack_require__(/*! extend-shallow */ \"(rsc)/./node_modules/extend-shallow/index.js\");\nvar red = __webpack_require__(/*! ansi-red */ \"(rsc)/./node_modules/ansi-red/index.js\");\n\n/**\n * Expose `parser` module\n */\n\nvar parser = module.exports;\n\n/**\n * Requires cache.\n */\n\nparser.requires = {};\n\n/**\n * Parse YAML front matter\n *\n * @param  {String} `str` The string to parse.\n * @param  {Object} `options` Options to pass to [js-yaml].\n * @return {Object} Parsed object of data.\n * @api public\n */\n\nparser.yaml = function(str, options) {\n  var opts = extend({strict: false, safeLoad: false}, options);\n  try {\n    var YAML = parser.requires.yaml || (parser.requires.yaml = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/index.js\"));\n    return opts.safeLoad ? YAML.safeLoad(str, options) : YAML.load(str, options);\n  } catch (err) {\n    if (opts.strict) {\n      throw new SyntaxError(msg('js-yaml', err));\n    } else {\n      return {};\n    }\n  }\n};\n\n\n/**\n * Parse JSON front matter\n *\n * @param  {String} `str` The string to parse.\n * @return {Object} Parsed object of data.\n * @api public\n */\n\nparser.json = function(str, options) {\n  var opts = extend({strict: false}, options);\n  try {\n    return JSON.parse(str);\n  } catch (err) {\n    if (opts.strict) {\n      throw new SyntaxError(msg('JSON', err));\n    } else {\n      return {};\n    }\n  }\n};\n\n\n/**\n * Parse JavaScript front matter. To use javascript front-matter, you must\n * set `options.eval` to `true`.\n *\n * By default, javascript code is wrapped in a function that is immediately\n * executed when the parser is called. Thus, to be returned as a useful object,\n * code should be written as object properties.\n *\n * **Example:**\n *\n * ```markdown\n * ---js\n * title: 'autodetect-javascript',\n * // this function won't be invoked when the parser is called\n * fn: {\n *   reverse: function(str) {\n *     return str.split('').reverse().join('');\n *   }\n * }\n * ---\n * ```\n *\n * @param  {String} `str` The string to parse.\n * @param  {Object} `options` Set `options.wrapped` to `false` to enable writing raw, un-wrapped javascript.\n * @return {Object} Parsed object of data.\n * @api public\n */\n\nparser.javascript = function(str, options) {\n  var opts = extend({wrapped: true, eval: false, strict: false}, options);\n  if (opts.eval) {\n    if (opts.wrapped) {\n      str = 'function data() {return {' + str + '}; } data();';\n    }\n    try {\n      return eval(str);\n    } catch (err) {\n      throw new SyntaxError(msg('javascript', err));\n    }\n    return {};\n  } else {\n\n    // if `eval` isn't set\n    if (opts.strict) {\n      throw new Error(evalError('javascript'));\n    } else {\n      console.error(evalError('javascript', true));\n    }\n  }\n};\n\n\n/**\n * Alias for `parse.javascript()`.\n *\n * @api public\n */\n\nparser.js = parser.javascript;\n\n\n/**\n * Parse Coffee-Script front matter. To use coffee front-matter, you must\n * set `options.eval` to `true`.\n *\n * @param  {String} `str` The string to parse.\n * @param  {Object} `options` Options to pass to [coffee-script].\n * @return {Object} Parsed object of data.\n * @api public\n */\n\nparser.coffee = function(str, options) {\n  var opts = extend({eval: false, strict: false}, options);\n  if (opts.eval) {\n    try {\n      var coffee = parser.requires.coffee || (parser.requires.coffee = __webpack_require__(/*! coffee-script */ \"(rsc)/./node_modules/coffee-script/lib/coffee-script/coffee-script.js\"));\n      return coffee['eval'](str, options);\n    } catch (err) {\n      throw new SyntaxError(msg('coffee-script', err));\n    }\n  } else {\n\n    // if `eval` isn't set\n    if (opts.strict) {\n      throw new Error(evalError('coffee'));\n    } else {\n      console.error(evalError('coffee', true));\n    }\n  }\n};\n\n/**\n * Alias for `parse.coffee()`.\n *\n * @api public\n */\n\nparser.cson = parser.coffee;\n\n/**\n * Parse TOML front matter.\n *\n * @param  {String} `str` The string to parse.\n * @param  {Object} `options` Options to pass to [toml-node].\n * @return {Object} Parsed object of data.\n * @api public\n */\n\nparser.toml = function(str, opts) {\n  try {\n    var toml = parser.requires.toml || (parser.requires.toml = __webpack_require__(/*! toml */ \"(rsc)/./node_modules/toml/index.js\"));\n    return toml.parse(str);\n  } catch (err) {\n    if (opts.strict) {\n      throw new SyntaxError(msg('TOML', err));\n    } else {\n      return {};\n    }\n  }\n};\n\n/**\n * Normalize error messages\n */\n\nfunction msg(lang, err) {\n  return 'gray-matter parser [' + lang + ']: ' + err;\n}\n\nfunction evalError(lang, color) {\n  var msg = '[gray-matter]: to parse ' + lang + ' set `options.eval` to `true`';\n  return color ? red(msg) : msg;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3JheS1tYXR0ZXIvbGliL3BhcnNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7QUFHYjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLG9FQUFnQjtBQUNyQyxVQUFVLG1CQUFPLENBQUMsd0RBQVU7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQSwrREFBK0QsbUJBQU8sQ0FBQyxzREFBUztBQUNoRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQTtBQUNBLDhCQUE4QixRQUFRLGdCQUFnQixPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsdUVBQXVFLG1CQUFPLENBQUMsNEZBQWU7QUFDOUY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELG1CQUFPLENBQUMsZ0RBQU07QUFDN0U7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FyZS8uL25vZGVfbW9kdWxlcy9ncmF5LW1hdHRlci9saWIvcGFyc2Vycy5qcz9kMTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZ3JheS1tYXR0ZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2dyYXktbWF0dGVyLmdpdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIHJlZCA9IHJlcXVpcmUoJ2Fuc2ktcmVkJyk7XG5cbi8qKlxuICogRXhwb3NlIGBwYXJzZXJgIG1vZHVsZVxuICovXG5cbnZhciBwYXJzZXIgPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBSZXF1aXJlcyBjYWNoZS5cbiAqL1xuXG5wYXJzZXIucmVxdWlyZXMgPSB7fTtcblxuLyoqXG4gKiBQYXJzZSBZQU1MIGZyb250IG1hdHRlclxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgIE9wdGlvbnMgdG8gcGFzcyB0byBbanMteWFtbF0uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFBhcnNlZCBvYmplY3Qgb2YgZGF0YS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGFyc2VyLnlhbWwgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdDogZmFsc2UsIHNhZmVMb2FkOiBmYWxzZX0sIG9wdGlvbnMpO1xuICB0cnkge1xuICAgIHZhciBZQU1MID0gcGFyc2VyLnJlcXVpcmVzLnlhbWwgfHwgKHBhcnNlci5yZXF1aXJlcy55YW1sID0gcmVxdWlyZSgnanMteWFtbCcpKTtcbiAgICByZXR1cm4gb3B0cy5zYWZlTG9hZCA/IFlBTUwuc2FmZUxvYWQoc3RyLCBvcHRpb25zKSA6IFlBTUwubG9hZChzdHIsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0cy5zdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihtc2coJ2pzLXlhbWwnLCBlcnIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlIEpTT04gZnJvbnQgbWF0dGVyXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgb2JqZWN0IG9mIGRhdGEuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBhcnNlci5qc29uID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHtzdHJpY3Q6IGZhbHNlfSwgb3B0aW9ucyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IobXNnKCdKU09OJywgZXJyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZSBKYXZhU2NyaXB0IGZyb250IG1hdHRlci4gVG8gdXNlIGphdmFzY3JpcHQgZnJvbnQtbWF0dGVyLCB5b3UgbXVzdFxuICogc2V0IGBvcHRpb25zLmV2YWxgIHRvIGB0cnVlYC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBqYXZhc2NyaXB0IGNvZGUgaXMgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHRoYXQgaXMgaW1tZWRpYXRlbHlcbiAqIGV4ZWN1dGVkIHdoZW4gdGhlIHBhcnNlciBpcyBjYWxsZWQuIFRodXMsIHRvIGJlIHJldHVybmVkIGFzIGEgdXNlZnVsIG9iamVjdCxcbiAqIGNvZGUgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgb2JqZWN0IHByb3BlcnRpZXMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKlxuICogYGBgbWFya2Rvd25cbiAqIC0tLWpzXG4gKiB0aXRsZTogJ2F1dG9kZXRlY3QtamF2YXNjcmlwdCcsXG4gKiAvLyB0aGlzIGZ1bmN0aW9uIHdvbid0IGJlIGludm9rZWQgd2hlbiB0aGUgcGFyc2VyIGlzIGNhbGxlZFxuICogZm46IHtcbiAqICAgcmV2ZXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gKiAgICAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICogICB9XG4gKiB9XG4gKiAtLS1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgIFNldCBgb3B0aW9ucy53cmFwcGVkYCB0byBgZmFsc2VgIHRvIGVuYWJsZSB3cml0aW5nIHJhdywgdW4td3JhcHBlZCBqYXZhc2NyaXB0LlxuICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgb2JqZWN0IG9mIGRhdGEuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBhcnNlci5qYXZhc2NyaXB0ID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt3cmFwcGVkOiB0cnVlLCBldmFsOiBmYWxzZSwgc3RyaWN0OiBmYWxzZX0sIG9wdGlvbnMpO1xuICBpZiAob3B0cy5ldmFsKSB7XG4gICAgaWYgKG9wdHMud3JhcHBlZCkge1xuICAgICAgc3RyID0gJ2Z1bmN0aW9uIGRhdGEoKSB7cmV0dXJuIHsnICsgc3RyICsgJ307IH0gZGF0YSgpOyc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZXZhbChzdHIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKG1zZygnamF2YXNjcmlwdCcsIGVycikpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBpZiBgZXZhbGAgaXNuJ3Qgc2V0XG4gICAgaWYgKG9wdHMuc3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXZhbEVycm9yKCdqYXZhc2NyaXB0JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGV2YWxFcnJvcignamF2YXNjcmlwdCcsIHRydWUpKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBbGlhcyBmb3IgYHBhcnNlLmphdmFzY3JpcHQoKWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5wYXJzZXIuanMgPSBwYXJzZXIuamF2YXNjcmlwdDtcblxuXG4vKipcbiAqIFBhcnNlIENvZmZlZS1TY3JpcHQgZnJvbnQgbWF0dGVyLiBUbyB1c2UgY29mZmVlIGZyb250LW1hdHRlciwgeW91IG11c3RcbiAqIHNldCBgb3B0aW9ucy5ldmFsYCB0byBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2AgT3B0aW9ucyB0byBwYXNzIHRvIFtjb2ZmZWUtc2NyaXB0XS5cbiAqIEByZXR1cm4ge09iamVjdH0gUGFyc2VkIG9iamVjdCBvZiBkYXRhLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5wYXJzZXIuY29mZmVlID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHtldmFsOiBmYWxzZSwgc3RyaWN0OiBmYWxzZX0sIG9wdGlvbnMpO1xuICBpZiAob3B0cy5ldmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjb2ZmZWUgPSBwYXJzZXIucmVxdWlyZXMuY29mZmVlIHx8IChwYXJzZXIucmVxdWlyZXMuY29mZmVlID0gcmVxdWlyZSgnY29mZmVlLXNjcmlwdCcpKTtcbiAgICAgIHJldHVybiBjb2ZmZWVbJ2V2YWwnXShzdHIsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKG1zZygnY29mZmVlLXNjcmlwdCcsIGVycikpO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIC8vIGlmIGBldmFsYCBpc24ndCBzZXRcbiAgICBpZiAob3B0cy5zdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihldmFsRXJyb3IoJ2NvZmZlZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihldmFsRXJyb3IoJ2NvZmZlZScsIHRydWUpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIGBwYXJzZS5jb2ZmZWUoKWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5wYXJzZXIuY3NvbiA9IHBhcnNlci5jb2ZmZWU7XG5cbi8qKlxuICogUGFyc2UgVE9NTCBmcm9udCBtYXR0ZXIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2AgT3B0aW9ucyB0byBwYXNzIHRvIFt0b21sLW5vZGVdLlxuICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgb2JqZWN0IG9mIGRhdGEuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBhcnNlci50b21sID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIHRyeSB7XG4gICAgdmFyIHRvbWwgPSBwYXJzZXIucmVxdWlyZXMudG9tbCB8fCAocGFyc2VyLnJlcXVpcmVzLnRvbWwgPSByZXF1aXJlKCd0b21sJykpO1xuICAgIHJldHVybiB0b21sLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChvcHRzLnN0cmljdCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKG1zZygnVE9NTCcsIGVycikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBlcnJvciBtZXNzYWdlc1xuICovXG5cbmZ1bmN0aW9uIG1zZyhsYW5nLCBlcnIpIHtcbiAgcmV0dXJuICdncmF5LW1hdHRlciBwYXJzZXIgWycgKyBsYW5nICsgJ106ICcgKyBlcnI7XG59XG5cbmZ1bmN0aW9uIGV2YWxFcnJvcihsYW5nLCBjb2xvcikge1xuICB2YXIgbXNnID0gJ1tncmF5LW1hdHRlcl06IHRvIHBhcnNlICcgKyBsYW5nICsgJyBzZXQgYG9wdGlvbnMuZXZhbGAgdG8gYHRydWVgJztcbiAgcmV0dXJuIGNvbG9yID8gcmVkKG1zZykgOiBtc2c7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gray-matter/lib/parsers.js\n");

/***/ })

};
;